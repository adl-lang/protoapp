module common.capability {

import common.http.HttpRateLimit;

// eg
// struct PublicApi {
//   HttpPost<LoginReq, LoginCapabilityResp> login = {...}
//   CapabilityApi<String, AppCapability, TokenApi> tokenApi = {
//     "service": {}
//   };
//   CapabilityApi<String, AppCapability, AdminRoleTokenApi> adminTokenApi = {
//     "service": {}
//   };
// };
// struct TokenApi { .. };
// struct AdminRoleTokenApi { .. };



/// Used to create a field inside an API struct which represents a section of the api requiring a token.
/// C is the type of the client-side token
/// S is the type of the server-side capability
/// V is the type of the API struct requiring the capability
struct CapabilityApi<C,S,V> {
  TypeToken<C> token = null;
  TypeToken<S> cap = null;
  String service_prefix = "";
  V service;
  String name = "";
  DeliveryMethod token_delivery;
};

union DeliveryMethod {
  /// don't send the token back to the server
  Void none;
  // /// Use a stardard http mechanism.
  // /// The mechanism differs depending on the http method
  // /// post
  // /// Uses the CapCall type ie. {"token": xxx, "payload": yyy}
  // /// get
  // /// Add the token as a query param ie. ?token=xxx
  // Void http;
  /// add as an "authorization: Bearer" headder
  Void jwt;
  /// add as a cookie, the provided string in the cookie name
  String header;
};

// /// Used to annotation api field as an api call which creates a cap.
// /// more accurately, since generic types can be used as annotation type, used to create a type alias which is used as the annotation.
// struct CapabilityDefn<C,S> {
//   TypeToken<C> token = null;
//   TypeToken<S> cap = null;
// };

// note CapabilityToken is not yet used.
// the idea is to use one of the other to generate stuff (fluent api or sequence diags, ...)

/// Used to annotation resp struct of branch of resp union which creates a cap.
/// more accurately, since generic types can be used as annotation type, used to create a type alias which is used as the annotation.
struct CapabilityToken<S> {
  TypeToken<S> cap = null;
};

// same as http.HttpGet & HttpPost without the security

struct HttpGet<O> {
  String path;
  Nullable<HttpRateLimit> rateLimit = null;
  TypeToken<O> respType = null;
};

struct HttpPost<I,O> {
  String path;
  Nullable<HttpRateLimit> rateLimit = null;
  TypeToken<I> reqType = null;
  TypeToken<O> respType = null;
};

struct CapCall<C,P> {
  C token;
  P payload;
};

};