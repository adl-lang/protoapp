// Code generated by goadlc v3 - DO NOT EDIT.
package types

import (
	"fmt"
	"github.com/adl-lang/goadl_common/common/capability"
	strings2 "github.com/adl-lang/goadl_common/common/strings"
	"github.com/adl-lang/goadl_protoapp/protoapp/db"
	"time"
)

type AccessToken strings2.StringNE

type AccessTokenMarker = capability.CapabilityToken[AccessToken]

type AdminAccessToken strings2.StringNE

type AdminAccessTokenMarker = capability.CapabilityToken[AdminAccessToken]

type LoginReq struct {
	_LoginReq
}

type _LoginReq struct {
	Email    strings2.StringNE `json:"email"`
	Password strings2.Password `json:"password"`
}

func MakeAll_LoginReq(
	email strings2.StringNE,
	password strings2.Password,
) LoginReq {
	return LoginReq{
		_LoginReq{
			Email:    email,
			Password: password,
		},
	}
}

func Make_LoginReq(
	email strings2.StringNE,
	password strings2.Password,
) LoginReq {
	ret := LoginReq{
		_LoginReq{
			Email:    email,
			Password: password,
		},
	}
	return ret
}

type LoginResp struct {
	Branch LoginRespBranch
}

type LoginRespBranch interface {
	isLoginRespBranch()
}

func (*LoginResp) MakeNewBranch(key string) (any, error) {
	switch key {
	case "tokens":
		return &_LoginResp_Tokens{}, nil
	case "invalid_credentials":
		return &_LoginResp_Invalid_credentials{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _LoginResp_Tokens struct {
	V LoginTokens `branch:"tokens"`
}
type _LoginResp_Invalid_credentials struct {
	V struct{} `branch:"invalid_credentials"`
}

func (_LoginResp_Tokens) isLoginRespBranch()              {}
func (_LoginResp_Invalid_credentials) isLoginRespBranch() {}

func Make_LoginResp_tokens(v LoginTokens) LoginResp {
	return LoginResp{
		_LoginResp_Tokens{v},
	}
}

func Make_LoginResp_invalid_credentials() LoginResp {
	return LoginResp{
		_LoginResp_Invalid_credentials{struct{}{}},
	}
}

func (un LoginResp) Cast_tokens() (LoginTokens, bool) {
	br, ok := un.Branch.(_LoginResp_Tokens)
	return br.V, ok
}

func (un LoginResp) Cast_invalid_credentials() (struct{}, bool) {
	br, ok := un.Branch.(_LoginResp_Invalid_credentials)
	return br.V, ok
}

func Handle_LoginResp[T any](
	_in LoginResp,
	tokens func(tokens LoginTokens) T,
	invalid_credentials func(invalid_credentials struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _LoginResp_Tokens:
		if tokens != nil {
			return tokens(_b.V)
		}
	case _LoginResp_Invalid_credentials:
		if invalid_credentials != nil {
			return invalid_credentials(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : LoginResp")
}

func HandleWithErr_LoginResp[T any](
	_in LoginResp,
	tokens func(tokens LoginTokens) (T, error),
	invalid_credentials func(invalid_credentials struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _LoginResp_Tokens:
		if tokens != nil {
			return tokens(_b.V)
		}
	case _LoginResp_Invalid_credentials:
		if invalid_credentials != nil {
			return invalid_credentials(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : LoginResp")
}

type LoginTokens struct {
	_LoginTokens
}

type _LoginTokens struct {
	Access_jwt  strings2.StringNE `json:"access_jwt"`
	Refresh_jwt strings2.StringNE `json:"refresh_jwt"`
}

func MakeAll_LoginTokens(
	access_jwt strings2.StringNE,
	refresh_jwt strings2.StringNE,
) LoginTokens {
	return LoginTokens{
		_LoginTokens{
			Access_jwt:  access_jwt,
			Refresh_jwt: refresh_jwt,
		},
	}
}

func Make_LoginTokens(
	access_jwt strings2.StringNE,
	refresh_jwt strings2.StringNE,
) LoginTokens {
	ret := LoginTokens{
		_LoginTokens{
			Access_jwt:  access_jwt,
			Refresh_jwt: refresh_jwt,
		},
	}
	return ret
}

type Message struct {
	_Message
}

type _Message struct {
	Id            db.MessageId      `json:"id"`
	Posted_at     time.Time         `json:"posted_at"`
	User_fullname string            `json:"user_fullname"`
	Message       strings2.StringML `json:"message"`
}

func MakeAll_Message(
	id db.MessageId,
	posted_at time.Time,
	user_fullname string,
	message strings2.StringML,
) Message {
	return Message{
		_Message{
			Id:            id,
			Posted_at:     posted_at,
			User_fullname: user_fullname,
			Message:       message,
		},
	}
}

func Make_Message(
	id db.MessageId,
	posted_at time.Time,
	user_fullname string,
	message strings2.StringML,
) Message {
	ret := Message{
		_Message{
			Id:            id,
			Posted_at:     posted_at,
			User_fullname: user_fullname,
			Message:       message,
		},
	}
	return ret
}

type NewMessageReq struct {
	_NewMessageReq
}

type _NewMessageReq struct {
	Message strings2.StringML `json:"message"`
}

func MakeAll_NewMessageReq(
	message strings2.StringML,
) NewMessageReq {
	return NewMessageReq{
		_NewMessageReq{
			Message: message,
		},
	}
}

func Make_NewMessageReq(
	message strings2.StringML,
) NewMessageReq {
	ret := NewMessageReq{
		_NewMessageReq{
			Message: message,
		},
	}
	return ret
}

type NewRefreshResp struct {
	Branch NewRefreshRespBranch
}

type NewRefreshRespBranch interface {
	isNewRefreshRespBranch()
}

func (*NewRefreshResp) MakeNewBranch(key string) (any, error) {
	switch key {
	case "refresh_jwt":
		return &_NewRefreshResp_Refresh_jwt{}, nil
	case "invalid_credentials":
		return &_NewRefreshResp_Invalid_credentials{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _NewRefreshResp_Refresh_jwt struct {
	V strings2.StringNE `branch:"refresh_jwt"`
}
type _NewRefreshResp_Invalid_credentials struct {
	V struct{} `branch:"invalid_credentials"`
}

func (_NewRefreshResp_Refresh_jwt) isNewRefreshRespBranch()         {}
func (_NewRefreshResp_Invalid_credentials) isNewRefreshRespBranch() {}

func Make_NewRefreshResp_refresh_jwt(v strings2.StringNE) NewRefreshResp {
	return NewRefreshResp{
		_NewRefreshResp_Refresh_jwt{v},
	}
}

func Make_NewRefreshResp_invalid_credentials() NewRefreshResp {
	return NewRefreshResp{
		_NewRefreshResp_Invalid_credentials{struct{}{}},
	}
}

func (un NewRefreshResp) Cast_refresh_jwt() (strings2.StringNE, bool) {
	br, ok := un.Branch.(_NewRefreshResp_Refresh_jwt)
	return br.V, ok
}

func (un NewRefreshResp) Cast_invalid_credentials() (struct{}, bool) {
	br, ok := un.Branch.(_NewRefreshResp_Invalid_credentials)
	return br.V, ok
}

func Handle_NewRefreshResp[T any](
	_in NewRefreshResp,
	refresh_jwt func(refresh_jwt strings2.StringNE) T,
	invalid_credentials func(invalid_credentials struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _NewRefreshResp_Refresh_jwt:
		if refresh_jwt != nil {
			return refresh_jwt(_b.V)
		}
	case _NewRefreshResp_Invalid_credentials:
		if invalid_credentials != nil {
			return invalid_credentials(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : NewRefreshResp")
}

func HandleWithErr_NewRefreshResp[T any](
	_in NewRefreshResp,
	refresh_jwt func(refresh_jwt strings2.StringNE) (T, error),
	invalid_credentials func(invalid_credentials struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _NewRefreshResp_Refresh_jwt:
		if refresh_jwt != nil {
			return refresh_jwt(_b.V)
		}
	case _NewRefreshResp_Invalid_credentials:
		if invalid_credentials != nil {
			return invalid_credentials(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : NewRefreshResp")
}

type PageReq struct {
	_PageReq
}

type _PageReq struct {
	Offset uint64 `json:"offset"`
	Limit  uint64 `json:"limit"`
}

func MakeAll_PageReq(
	offset uint64,
	limit uint64,
) PageReq {
	return PageReq{
		_PageReq{
			Offset: offset,
			Limit:  limit,
		},
	}
}

func Make_PageReq() PageReq {
	ret := PageReq{
		_PageReq{
			Offset: ((*PageReq)(nil)).Default_offset(),
			Limit:  ((*PageReq)(nil)).Default_limit(),
		},
	}
	return ret
}

func (*PageReq) Default_offset() uint64 {
	return 0
}
func (*PageReq) Default_limit() uint64 {
	return 20
}

type Paginated[T any] struct {
	_Paginated[T]
}

type _Paginated[T any] struct {
	Items          []T    `json:"items"`
	Current_offset uint64 `json:"current_offset"`
	Total_count    uint64 `json:"total_count"`
}

func MakeAll_Paginated[T any](
	items []T,
	current_offset uint64,
	total_count uint64,
) Paginated[T] {
	return Paginated[T]{
		_Paginated[T]{
			Items:          items,
			Current_offset: current_offset,
			Total_count:    total_count,
		},
	}
}

func Make_Paginated[T any](
	items []T,
	current_offset uint64,
	total_count uint64,
) Paginated[T] {
	ret := Paginated[T]{
		_Paginated[T]{
			Items:          items,
			Current_offset: current_offset,
			Total_count:    total_count,
		},
	}
	return ret
}

type QueryUsersReq struct {
	_QueryUsersReq
}

type _QueryUsersReq struct {
	Page PageReq `json:"page"`
}

func MakeAll_QueryUsersReq(
	page PageReq,
) QueryUsersReq {
	return QueryUsersReq{
		_QueryUsersReq{
			Page: page,
		},
	}
}

func Make_QueryUsersReq() QueryUsersReq {
	ret := QueryUsersReq{
		_QueryUsersReq{
			Page: ((*QueryUsersReq)(nil)).Default_page(),
		},
	}
	return ret
}

func (*QueryUsersReq) Default_page() PageReq {
	return MakeAll_PageReq(
		0,
		20,
	)
}

type RecentMessagesReq struct {
	_RecentMessagesReq
}

type _RecentMessagesReq struct {
	Page PageReq `json:"page"`
}

func MakeAll_RecentMessagesReq(
	page PageReq,
) RecentMessagesReq {
	return RecentMessagesReq{
		_RecentMessagesReq{
			Page: page,
		},
	}
}

func Make_RecentMessagesReq(
	page PageReq,
) RecentMessagesReq {
	ret := RecentMessagesReq{
		_RecentMessagesReq{
			Page: page,
		},
	}
	return ret
}

type RefreshReq struct {
	_RefreshReq
}

type _RefreshReq struct {
	Refresh_token *strings2.StringNE `json:"refresh_token"`
}

func MakeAll_RefreshReq(
	refresh_token *strings2.StringNE,
) RefreshReq {
	return RefreshReq{
		_RefreshReq{
			Refresh_token: refresh_token,
		},
	}
}

func Make_RefreshReq() RefreshReq {
	ret := RefreshReq{
		_RefreshReq{
			Refresh_token: ((*RefreshReq)(nil)).Default_refresh_token(),
		},
	}
	return ret
}

func (*RefreshReq) Default_refresh_token() *strings2.StringNE {
	return nil
}

type RefreshResp struct {
	Branch RefreshRespBranch
}

type RefreshRespBranch interface {
	isRefreshRespBranch()
}

func (*RefreshResp) MakeNewBranch(key string) (any, error) {
	switch key {
	case "access_token":
		return &_RefreshResp_Access_token{}, nil
	case "invalid_refresh_token":
		return &_RefreshResp_Invalid_refresh_token{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _RefreshResp_Access_token struct {
	V strings2.StringNE `branch:"access_token"`
}
type _RefreshResp_Invalid_refresh_token struct {
	V struct{} `branch:"invalid_refresh_token"`
}

func (_RefreshResp_Access_token) isRefreshRespBranch()          {}
func (_RefreshResp_Invalid_refresh_token) isRefreshRespBranch() {}

func Make_RefreshResp_access_token(v strings2.StringNE) RefreshResp {
	return RefreshResp{
		_RefreshResp_Access_token{v},
	}
}

func Make_RefreshResp_invalid_refresh_token() RefreshResp {
	return RefreshResp{
		_RefreshResp_Invalid_refresh_token{struct{}{}},
	}
}

func (un RefreshResp) Cast_access_token() (strings2.StringNE, bool) {
	br, ok := un.Branch.(_RefreshResp_Access_token)
	return br.V, ok
}

func (un RefreshResp) Cast_invalid_refresh_token() (struct{}, bool) {
	br, ok := un.Branch.(_RefreshResp_Invalid_refresh_token)
	return br.V, ok
}

func Handle_RefreshResp[T any](
	_in RefreshResp,
	access_token func(access_token strings2.StringNE) T,
	invalid_refresh_token func(invalid_refresh_token struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _RefreshResp_Access_token:
		if access_token != nil {
			return access_token(_b.V)
		}
	case _RefreshResp_Invalid_refresh_token:
		if invalid_refresh_token != nil {
			return invalid_refresh_token(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : RefreshResp")
}

func HandleWithErr_RefreshResp[T any](
	_in RefreshResp,
	access_token func(access_token strings2.StringNE) (T, error),
	invalid_refresh_token func(invalid_refresh_token struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _RefreshResp_Access_token:
		if access_token != nil {
			return access_token(_b.V)
		}
	case _RefreshResp_Invalid_refresh_token:
		if invalid_refresh_token != nil {
			return invalid_refresh_token(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : RefreshResp")
}

type RefreshToken strings2.StringNE

type RefreshTokenMarker = capability.CapabilityToken[RefreshToken]

type User struct {
	_User
}

type _User struct {
	Fullname strings2.StringNE     `json:"fullname"`
	Email    strings2.EmailAddress `json:"email"`
	Is_admin bool                  `json:"is_admin"`
}

func MakeAll_User(
	fullname strings2.StringNE,
	email strings2.EmailAddress,
	is_admin bool,
) User {
	return User{
		_User{
			Fullname: fullname,
			Email:    email,
			Is_admin: is_admin,
		},
	}
}

func Make_User(
	fullname strings2.StringNE,
	email strings2.EmailAddress,
	is_admin bool,
) User {
	ret := User{
		_User{
			Fullname: fullname,
			Email:    email,
			Is_admin: is_admin,
		},
	}
	return ret
}

type UserDetails struct {
	_UserDetails
}

type _UserDetails struct {
	Fullname strings2.StringNE     `json:"fullname"`
	Email    strings2.EmailAddress `json:"email"`
	Is_admin bool                  `json:"is_admin"`
	Password strings2.Password     `json:"password"`
}

func MakeAll_UserDetails(
	fullname strings2.StringNE,
	email strings2.EmailAddress,
	is_admin bool,
	password strings2.Password,
) UserDetails {
	return UserDetails{
		_UserDetails{
			Fullname: fullname,
			Email:    email,
			Is_admin: is_admin,
			Password: password,
		},
	}
}

func Make_UserDetails(
	fullname strings2.StringNE,
	email strings2.EmailAddress,
	is_admin bool,
	password strings2.Password,
) UserDetails {
	ret := UserDetails{
		_UserDetails{
			Fullname: fullname,
			Email:    email,
			Is_admin: is_admin,
			Password: password,
		},
	}
	return ret
}

type UserWithId = WithId[db.AppUserId, User]

type WithId[I any, T any] struct {
	_WithId[I, T]
}

type _WithId[I any, T any] struct {
	Id    I `json:"id"`
	Value T `json:"value"`
}

func MakeAll_WithId[I any, T any](
	id I,
	value T,
) WithId[I, T] {
	return WithId[I, T]{
		_WithId[I, T]{
			Id:    id,
			Value: value,
		},
	}
}

func Make_WithId[I any, T any](
	id I,
	value T,
) WithId[I, T] {
	ret := WithId[I, T]{
		_WithId[I, T]{
			Id:    id,
			Value: value,
		},
	}
	return ret
}
