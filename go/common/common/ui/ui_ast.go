// Code generated by goadlc v3 - DO NOT EDIT.
package ui

import (
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

func Texpr_FormGroupKey() adlast.ATypeExpr[FormGroupKey] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.ui", "FormGroupKey"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[FormGroupKey](te)
}

func AST_FormGroupKey() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"FormGroupKey",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("common.ui", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.ui", "FormGroupKey"),
		AST_FormGroupKey(),
	)
}

func Texpr_FormGroups() adlast.ATypeExpr[FormGroups] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.ui", "FormGroups"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[FormGroups](te)
}

func AST_FormGroups() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"FormGroups",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"defaultKey",
						"defaultKey",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_reference(
								adlast.MakeAll_ScopedName(
									"common.ui",
									"FormGroupKey",
								),
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
					adlast.MakeAll_Field(
						"labels",
						"labels",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Vector",
							),
							[]adlast.TypeExpr{
								adlast.MakeAll_TypeExpr(
									adlast.Make_TypeRef_reference(
										adlast.MakeAll_ScopedName(
											"sys.types",
											"Pair",
										),
									),
									[]adlast.TypeExpr{
										adlast.MakeAll_TypeExpr(
											adlast.Make_TypeRef_reference(
												adlast.MakeAll_ScopedName(
													"common.ui",
													"FormGroupKey",
												),
											),
											[]adlast.TypeExpr{},
										),
										adlast.MakeAll_TypeExpr(
											adlast.Make_TypeRef_primitive(
												"String",
											),
											[]adlast.TypeExpr{},
										),
									},
								),
							},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("common.ui", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.ui", "FormGroups"),
		AST_FormGroups(),
	)
}

func Texpr_FormLabel() adlast.ATypeExpr[FormLabel] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.ui", "FormLabel"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[FormLabel](te)
}

func AST_FormLabel() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"FormLabel",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{},
	)
	return adlast.Make_ScopedDecl("common.ui", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.ui", "FormLabel"),
		AST_FormLabel(),
	)
}

func Texpr_ValidRegex() adlast.ATypeExpr[ValidRegex] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.ui", "ValidRegex"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[ValidRegex](te)
}

func AST_ValidRegex() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"ValidRegex",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"regex",
						"regex",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"String",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "The regexp that must be matched\n"},
					),
					adlast.MakeAll_Field(
						"description",
						"description",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"String",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "A (short) user readable string describing the\nexpected text.\n"},
					),
					adlast.MakeAll_Field(
						"returnGroup",
						"returnGroup",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Int8",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_just[any](
							0,
						),
						customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "The regex group index to return if matches\n0 is the entire string\n"},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "An field/type alias annotation to constrain the\nvalues allowed by a string to a regular expression\n"},
	)
	return adlast.Make_ScopedDecl("common.ui", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.ui", "ValidRegex"),
		AST_ValidRegex(),
	)
}

func Texpr_ValidValues() adlast.ATypeExpr[ValidValues] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.ui", "ValidValues"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[ValidValues](te)
}

func AST_ValidValues() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"ValidValues",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_struct_(
			adlast.MakeAll_Struct(
				[]adlast.Ident{},
				[]adlast.Field{
					adlast.MakeAll_Field(
						"values",
						"values",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"Vector",
							),
							[]adlast.TypeExpr{
								adlast.MakeAll_TypeExpr(
									adlast.Make_TypeRef_primitive(
										"String",
									),
									[]adlast.TypeExpr{},
								),
							},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "The allowed values\n"},
					),
					adlast.MakeAll_Field(
						"description",
						"description",
						adlast.MakeAll_TypeExpr(
							adlast.Make_TypeRef_primitive(
								"String",
							),
							[]adlast.TypeExpr{},
						),
						types.Make_Maybe_nothing[any](),
						customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "A (short) user readable string describing the\nexpected text.\n"},
					),
				},
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "An field/type alias annotation to constrain the\nvalues allowed by a string to the enumerated values\n"},
	)
	return adlast.Make_ScopedDecl("common.ui", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.ui", "ValidValues"),
		AST_ValidValues(),
	)
}
