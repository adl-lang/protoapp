// Code generated by goadlc v3 - DO NOT EDIT.
package http

import (
	"fmt"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
)

type HttpDelete[P any, O any] struct {
	_HttpDelete[P, O]
}

type _HttpDelete[P any, O any] struct {
	Path       string              `json:"path"`
	Security   HttpSecurity        `json:"security"`
	ParamsType adlast.ATypeExpr[P] `json:"paramsType"`
	RespType   adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpDelete[P any, O any](
	path string,
	security HttpSecurity,
	paramstype adlast.ATypeExpr[P],
	resptype adlast.ATypeExpr[O],
) HttpDelete[P, O] {
	return HttpDelete[P, O]{
		_HttpDelete[P, O]{
			Path:       path,
			Security:   security,
			ParamsType: paramstype,
			RespType:   resptype,
		},
	}
}

// struct HttpDelete contains at least one TypeToken, not generating Make_ funcs

type HttpGet[O any] struct {
	_HttpGet[O]
}

type _HttpGet[O any] struct {
	Path      string              `json:"path"`
	Security  HttpSecurity        `json:"security"`
	RateLimit *HttpRateLimit      `json:"rateLimit"`
	RespType  adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpGet[O any](
	path string,
	security HttpSecurity,
	ratelimit *HttpRateLimit,
	resptype adlast.ATypeExpr[O],
) HttpGet[O] {
	return HttpGet[O]{
		_HttpGet[O]{
			Path:      path,
			Security:  security,
			RateLimit: ratelimit,
			RespType:  resptype,
		},
	}
}

// struct HttpGet contains at least one TypeToken, not generating Make_ funcs

type HttpPost[I any, O any] struct {
	_HttpPost[I, O]
}

type _HttpPost[I any, O any] struct {
	Path      string              `json:"path"`
	Security  HttpSecurity        `json:"security"`
	RateLimit *HttpRateLimit      `json:"rateLimit"`
	ReqType   adlast.ATypeExpr[I] `json:"reqType"`
	RespType  adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpPost[I any, O any](
	path string,
	security HttpSecurity,
	ratelimit *HttpRateLimit,
	reqtype adlast.ATypeExpr[I],
	resptype adlast.ATypeExpr[O],
) HttpPost[I, O] {
	return HttpPost[I, O]{
		_HttpPost[I, O]{
			Path:      path,
			Security:  security,
			RateLimit: ratelimit,
			ReqType:   reqtype,
			RespType:  resptype,
		},
	}
}

// struct HttpPost contains at least one TypeToken, not generating Make_ funcs

type HttpPut[I any, O any] struct {
	_HttpPut[I, O]
}

type _HttpPut[I any, O any] struct {
	Path      string              `json:"path"`
	Security  HttpSecurity        `json:"security"`
	RateLimit *HttpRateLimit      `json:"rateLimit"`
	ReqType   adlast.ATypeExpr[I] `json:"reqType"`
	RespType  adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpPut[I any, O any](
	path string,
	security HttpSecurity,
	ratelimit *HttpRateLimit,
	reqtype adlast.ATypeExpr[I],
	resptype adlast.ATypeExpr[O],
) HttpPut[I, O] {
	return HttpPut[I, O]{
		_HttpPut[I, O]{
			Path:      path,
			Security:  security,
			RateLimit: ratelimit,
			ReqType:   reqtype,
			RespType:  resptype,
		},
	}
}

// struct HttpPut contains at least one TypeToken, not generating Make_ funcs

type HttpRateLimit struct {
	_HttpRateLimit
}

type _HttpRateLimit struct {
	MaxRequests uint32            `json:"maxRequests"`
	PerTimeUnit RateLimitTimeUnit `json:"perTimeUnit"`
}

func MakeAll_HttpRateLimit(
	maxrequests uint32,
	pertimeunit RateLimitTimeUnit,
) HttpRateLimit {
	return HttpRateLimit{
		_HttpRateLimit{
			MaxRequests: maxrequests,
			PerTimeUnit: pertimeunit,
		},
	}
}

func Make_HttpRateLimit(
	maxrequests uint32,
	pertimeunit RateLimitTimeUnit,
) HttpRateLimit {
	ret := HttpRateLimit{
		_HttpRateLimit{
			MaxRequests: maxrequests,
			PerTimeUnit: pertimeunit,
		},
	}
	return ret
}

type HttpSecurity struct {
	Branch HttpSecurityBranch
}

type HttpSecurityBranch interface {
	isHttpSecurityBranch()
}

func (*HttpSecurity) MakeNewBranch(key string) (any, error) {
	switch key {
	case "public":
		return &_HttpSecurity_Public{}, nil
	case "token":
		return &_HttpSecurity_Token{}, nil
	case "tokenWithRole":
		return &_HttpSecurity_TokenWithRole{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _HttpSecurity_Public struct {
	V struct{} `branch:"public"`
}
type _HttpSecurity_Token struct {
	V struct{} `branch:"token"`
}
type _HttpSecurity_TokenWithRole struct {
	V string `branch:"tokenWithRole"`
}

func (_HttpSecurity_Public) isHttpSecurityBranch()        {}
func (_HttpSecurity_Token) isHttpSecurityBranch()         {}
func (_HttpSecurity_TokenWithRole) isHttpSecurityBranch() {}

func Make_HttpSecurity_public() HttpSecurity {
	return HttpSecurity{
		_HttpSecurity_Public{struct{}{}},
	}
}

func Make_HttpSecurity_token() HttpSecurity {
	return HttpSecurity{
		_HttpSecurity_Token{struct{}{}},
	}
}

func Make_HttpSecurity_tokenWithRole(v string) HttpSecurity {
	return HttpSecurity{
		_HttpSecurity_TokenWithRole{v},
	}
}

func (un HttpSecurity) Cast_public() (struct{}, bool) {
	br, ok := un.Branch.(_HttpSecurity_Public)
	return br.V, ok
}

func (un HttpSecurity) Cast_token() (struct{}, bool) {
	br, ok := un.Branch.(_HttpSecurity_Token)
	return br.V, ok
}

func (un HttpSecurity) Cast_tokenWithRole() (string, bool) {
	br, ok := un.Branch.(_HttpSecurity_TokenWithRole)
	return br.V, ok
}

func Handle_HttpSecurity[T any](
	_in HttpSecurity,
	public func(public struct{}) T,
	token func(token struct{}) T,
	tokenWithRole func(tokenWithRole string) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _HttpSecurity_Public:
		if public != nil {
			return public(_b.V)
		}
	case _HttpSecurity_Token:
		if token != nil {
			return token(_b.V)
		}
	case _HttpSecurity_TokenWithRole:
		if tokenWithRole != nil {
			return tokenWithRole(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : HttpSecurity")
}

func HandleWithErr_HttpSecurity[T any](
	_in HttpSecurity,
	public func(public struct{}) (T, error),
	token func(token struct{}) (T, error),
	tokenWithRole func(tokenWithRole string) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _HttpSecurity_Public:
		if public != nil {
			return public(_b.V)
		}
	case _HttpSecurity_Token:
		if token != nil {
			return token(_b.V)
		}
	case _HttpSecurity_TokenWithRole:
		if tokenWithRole != nil {
			return tokenWithRole(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : HttpSecurity")
}

type RateLimitTimeUnit struct {
	Branch RateLimitTimeUnitBranch
}

type RateLimitTimeUnitBranch interface {
	isRateLimitTimeUnitBranch()
}

func (*RateLimitTimeUnit) MakeNewBranch(key string) (any, error) {
	switch key {
	case "second":
		return &_RateLimitTimeUnit_Second{}, nil
	case "minute":
		return &_RateLimitTimeUnit_Minute{}, nil
	case "hour":
		return &_RateLimitTimeUnit_Hour{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _RateLimitTimeUnit_Second struct {
	V struct{} `branch:"second"`
}
type _RateLimitTimeUnit_Minute struct {
	V struct{} `branch:"minute"`
}
type _RateLimitTimeUnit_Hour struct {
	V struct{} `branch:"hour"`
}

func (_RateLimitTimeUnit_Second) isRateLimitTimeUnitBranch() {}
func (_RateLimitTimeUnit_Minute) isRateLimitTimeUnitBranch() {}
func (_RateLimitTimeUnit_Hour) isRateLimitTimeUnitBranch()   {}

func Make_RateLimitTimeUnit_second() RateLimitTimeUnit {
	return RateLimitTimeUnit{
		_RateLimitTimeUnit_Second{struct{}{}},
	}
}

func Make_RateLimitTimeUnit_minute() RateLimitTimeUnit {
	return RateLimitTimeUnit{
		_RateLimitTimeUnit_Minute{struct{}{}},
	}
}

func Make_RateLimitTimeUnit_hour() RateLimitTimeUnit {
	return RateLimitTimeUnit{
		_RateLimitTimeUnit_Hour{struct{}{}},
	}
}

func (un RateLimitTimeUnit) Cast_second() (struct{}, bool) {
	br, ok := un.Branch.(_RateLimitTimeUnit_Second)
	return br.V, ok
}

func (un RateLimitTimeUnit) Cast_minute() (struct{}, bool) {
	br, ok := un.Branch.(_RateLimitTimeUnit_Minute)
	return br.V, ok
}

func (un RateLimitTimeUnit) Cast_hour() (struct{}, bool) {
	br, ok := un.Branch.(_RateLimitTimeUnit_Hour)
	return br.V, ok
}

func Handle_RateLimitTimeUnit[T any](
	_in RateLimitTimeUnit,
	second func(second struct{}) T,
	minute func(minute struct{}) T,
	hour func(hour struct{}) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _RateLimitTimeUnit_Second:
		if second != nil {
			return second(_b.V)
		}
	case _RateLimitTimeUnit_Minute:
		if minute != nil {
			return minute(_b.V)
		}
	case _RateLimitTimeUnit_Hour:
		if hour != nil {
			return hour(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : RateLimitTimeUnit")
}

func HandleWithErr_RateLimitTimeUnit[T any](
	_in RateLimitTimeUnit,
	second func(second struct{}) (T, error),
	minute func(minute struct{}) (T, error),
	hour func(hour struct{}) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _RateLimitTimeUnit_Second:
		if second != nil {
			return second(_b.V)
		}
	case _RateLimitTimeUnit_Minute:
		if minute != nil {
			return minute(_b.V)
		}
	case _RateLimitTimeUnit_Hour:
		if hour != nil {
			return hour(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : RateLimitTimeUnit")
}

type Unit struct {
	_Unit
}

type _Unit struct {
}

func MakeAll_Unit() Unit {
	return Unit{
		_Unit{},
	}
}

func Make_Unit() Unit {
	ret := Unit{
		_Unit{},
	}
	return ret
}
