// Code generated by goadlc v3 - DO NOT EDIT.
package strings

import (
	goadl "github.com/adl-lang/goadl_rt/v3"
	"github.com/adl-lang/goadl_rt/v3/customtypes"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
	"github.com/adl-lang/goadl_rt/v3/sys/types"
)

func Texpr_EmailAddress() adlast.ATypeExpr[EmailAddress] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "EmailAddress"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[EmailAddress](te)
}

func AST_EmailAddress() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"EmailAddress",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("common.ui", "ValidRegex"): map[string]interface{}{"description": "an email address", "regex": "^\\s*((?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|\"(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21\\x23-\\x5b\\x5d-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])*\")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x21-\\x5a\\x53-\\x7f]|\\\\[\\x01-\\x09\\x0b\\x0c\\x0e-\\x7f])+)\\]))\\s*$", "returnGroup": 1}, adlast.Make_ScopedName("sys.annotations", "Doc"): "An email address\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "EmailAddress"),
		AST_EmailAddress(),
	)
}

func Texpr_Password() adlast.ATypeExpr[Password] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "Password"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[Password](te)
}

func AST_Password() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"Password",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "A password, which cannot be empty. Other constraints\nare application specific.\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "Password"),
		AST_Password(),
	)
}

func Texpr_StringANH() adlast.ATypeExpr[StringANH] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "StringANH"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StringANH](te)
}

func AST_StringANH() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StringANH",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("common.ui", "ValidRegex"): map[string]interface{}{"description": "alphanumeric", "regex": "^[A-Za-z][A-Za-z0-9-]*$", "returnGroup": 0}, adlast.Make_ScopedName("sys.annotations", "Doc"): "An alphanumeric string, with hyphens for separation.\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "StringANH"),
		AST_StringANH(),
	)
}

func Texpr_StringMD() adlast.ATypeExpr[StringMD] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "StringMD"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StringMD](te)
}

func AST_StringMD() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StringMD",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "A markdown text string\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "StringMD"),
		AST_StringMD(),
	)
}

func Texpr_StringML() adlast.ATypeExpr[StringML] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "StringML"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StringML](te)
}

func AST_StringML() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StringML",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("sys.annotations", "Doc"): "A multi line, free-form text string\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "StringML"),
		AST_StringML(),
	)
}

func Texpr_StringNE() adlast.ATypeExpr[StringNE] {
	te := adlast.Make_TypeExpr(
		adlast.Make_TypeRef_reference(
			adlast.Make_ScopedName("common.strings", "StringNE"),
		),
		[]adlast.TypeExpr{},
	)
	return adlast.Make_ATypeExpr[StringNE](te)
}

func AST_StringNE() adlast.ScopedDecl {
	decl := adlast.MakeAll_Decl(
		"StringNE",
		types.Make_Maybe_nothing[uint32](),
		adlast.Make_DeclType_type_(
			adlast.MakeAll_TypeDef(
				[]adlast.Ident{},
				adlast.MakeAll_TypeExpr(
					adlast.Make_TypeRef_primitive(
						"String",
					),
					[]adlast.TypeExpr{},
				),
			),
		),
		customtypes.MapMap[adlast.ScopedName, any]{adlast.Make_ScopedName("common.ui", "ValidRegex"): map[string]interface{}{"description": "non empty", "regex": "^.*\\S+.*$", "returnGroup": 0}, adlast.Make_ScopedName("sys.annotations", "Doc"): "A string that isn't empty, and isn't only whitespace.\n"},
	)
	return adlast.Make_ScopedDecl("common.strings", decl)
}

func init() {
	goadl.RESOLVER.Register(
		adlast.Make_ScopedName("common.strings", "StringNE"),
		AST_StringNE(),
	)
}
