// Code generated by goadlc v3 - DO NOT EDIT.
package capability

import (
	"fmt"
	"github.com/adl-lang/goadl_common/common/http"
	"github.com/adl-lang/goadl_rt/v3/sys/adlast"
)

type CapCall[C any, P any] struct {
	_CapCall[C, P]
}

type _CapCall[C any, P any] struct {
	Token   C `json:"token"`
	Payload P `json:"payload"`
}

func MakeAll_CapCall[C any, P any](
	token C,
	payload P,
) CapCall[C, P] {
	return CapCall[C, P]{
		_CapCall[C, P]{
			Token:   token,
			Payload: payload,
		},
	}
}

func Make_CapCall[C any, P any](
	token C,
	payload P,
) CapCall[C, P] {
	ret := CapCall[C, P]{
		_CapCall[C, P]{
			Token:   token,
			Payload: payload,
		},
	}
	return ret
}

type CapabilityApi[C any, S any, V any] struct {
	_CapabilityApi[C, S, V]
}

type _CapabilityApi[C any, S any, V any] struct {
	Token          adlast.ATypeExpr[C] `json:"token"`
	Cap            adlast.ATypeExpr[S] `json:"cap"`
	Service_prefix string              `json:"service_prefix"`
	Service        V                   `json:"service"`
	Name           string              `json:"name"`
	Token_delivery DeliveryMethod      `json:"token_delivery"`
}

func MakeAll_CapabilityApi[C any, S any, V any](
	token adlast.ATypeExpr[C],
	cap adlast.ATypeExpr[S],
	service_prefix string,
	service V,
	name string,
	token_delivery DeliveryMethod,
) CapabilityApi[C, S, V] {
	return CapabilityApi[C, S, V]{
		_CapabilityApi[C, S, V]{
			Token:          token,
			Cap:            cap,
			Service_prefix: service_prefix,
			Service:        service,
			Name:           name,
			Token_delivery: token_delivery,
		},
	}
}

// struct CapabilityApi contains at least one TypeToken, not generating Make_ funcs

type CapabilityToken[S any] struct {
	_CapabilityToken[S]
}

type _CapabilityToken[S any] struct {
	Cap adlast.ATypeExpr[S] `json:"cap"`
}

func MakeAll_CapabilityToken[S any](
	cap adlast.ATypeExpr[S],
) CapabilityToken[S] {
	return CapabilityToken[S]{
		_CapabilityToken[S]{
			Cap: cap,
		},
	}
}

// struct CapabilityToken contains at least one TypeToken, not generating Make_ funcs

type DeliveryMethod struct {
	Branch DeliveryMethodBranch
}

type DeliveryMethodBranch interface {
	isDeliveryMethodBranch()
}

func (*DeliveryMethod) MakeNewBranch(key string) (any, error) {
	switch key {
	case "none":
		return &_DeliveryMethod_None{}, nil
	case "bearer":
		return &_DeliveryMethod_Bearer{}, nil
	case "cookie":
		return &_DeliveryMethod_Cookie{}, nil
	}
	return nil, fmt.Errorf("unknown branch is : %s", key)
}

type _DeliveryMethod_None struct {
	V struct{} `branch:"none"`
}
type _DeliveryMethod_Bearer struct {
	V struct{} `branch:"bearer"`
}
type _DeliveryMethod_Cookie struct {
	V string `branch:"cookie"`
}

func (_DeliveryMethod_None) isDeliveryMethodBranch()   {}
func (_DeliveryMethod_Bearer) isDeliveryMethodBranch() {}
func (_DeliveryMethod_Cookie) isDeliveryMethodBranch() {}

func Make_DeliveryMethod_none() DeliveryMethod {
	return DeliveryMethod{
		_DeliveryMethod_None{struct{}{}},
	}
}

func Make_DeliveryMethod_bearer() DeliveryMethod {
	return DeliveryMethod{
		_DeliveryMethod_Bearer{struct{}{}},
	}
}

func Make_DeliveryMethod_cookie(v string) DeliveryMethod {
	return DeliveryMethod{
		_DeliveryMethod_Cookie{v},
	}
}

func (un DeliveryMethod) Cast_none() (struct{}, bool) {
	br, ok := un.Branch.(_DeliveryMethod_None)
	return br.V, ok
}

func (un DeliveryMethod) Cast_bearer() (struct{}, bool) {
	br, ok := un.Branch.(_DeliveryMethod_Bearer)
	return br.V, ok
}

func (un DeliveryMethod) Cast_cookie() (string, bool) {
	br, ok := un.Branch.(_DeliveryMethod_Cookie)
	return br.V, ok
}

func Handle_DeliveryMethod[T any](
	_in DeliveryMethod,
	none func(none struct{}) T,
	bearer func(bearer struct{}) T,
	cookie func(cookie string) T,
	_default func() T,
) T {
	switch _b := _in.Branch.(type) {
	case _DeliveryMethod_None:
		if none != nil {
			return none(_b.V)
		}
	case _DeliveryMethod_Bearer:
		if bearer != nil {
			return bearer(_b.V)
		}
	case _DeliveryMethod_Cookie:
		if cookie != nil {
			return cookie(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : DeliveryMethod")
}

func HandleWithErr_DeliveryMethod[T any](
	_in DeliveryMethod,
	none func(none struct{}) (T, error),
	bearer func(bearer struct{}) (T, error),
	cookie func(cookie string) (T, error),
	_default func() (T, error),
) (T, error) {
	switch _b := _in.Branch.(type) {
	case _DeliveryMethod_None:
		if none != nil {
			return none(_b.V)
		}
	case _DeliveryMethod_Bearer:
		if bearer != nil {
			return bearer(_b.V)
		}
	case _DeliveryMethod_Cookie:
		if cookie != nil {
			return cookie(_b.V)
		}
	}
	if _default != nil {
		return _default()
	}
	panic("unhandled branch in : DeliveryMethod")
}

type HttpGet[O any] struct {
	_HttpGet[O]
}

type _HttpGet[O any] struct {
	Path      string              `json:"path"`
	RateLimit *http.HttpRateLimit `json:"rateLimit"`
	RespType  adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpGet[O any](
	path string,
	ratelimit *http.HttpRateLimit,
	resptype adlast.ATypeExpr[O],
) HttpGet[O] {
	return HttpGet[O]{
		_HttpGet[O]{
			Path:      path,
			RateLimit: ratelimit,
			RespType:  resptype,
		},
	}
}

// struct HttpGet contains at least one TypeToken, not generating Make_ funcs

type HttpPost[I any, O any] struct {
	_HttpPost[I, O]
}

type _HttpPost[I any, O any] struct {
	Path      string              `json:"path"`
	RateLimit *http.HttpRateLimit `json:"rateLimit"`
	ReqType   adlast.ATypeExpr[I] `json:"reqType"`
	RespType  adlast.ATypeExpr[O] `json:"respType"`
}

func MakeAll_HttpPost[I any, O any](
	path string,
	ratelimit *http.HttpRateLimit,
	reqtype adlast.ATypeExpr[I],
	resptype adlast.ATypeExpr[O],
) HttpPost[I, O] {
	return HttpPost[I, O]{
		_HttpPost[I, O]{
			Path:      path,
			RateLimit: ratelimit,
			ReqType:   reqtype,
			RespType:  resptype,
		},
	}
}

// struct HttpPost contains at least one TypeToken, not generating Make_ funcs
